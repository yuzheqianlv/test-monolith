# Monolith 翻译功能集成指南

## 概述

本指南详细说明如何在 monolith 工具中集成翻译功能，实现对网页内容的自动翻译处理。

## 核心处理流程分析

### 当前 Monolith 处理流程
1. **HTML 解析** (`core.rs:170-180`) - 将输入转换为 DOM 树
2. **资源遍历** (`core.rs:203`) - 调用 `walk()` 函数遍历 DOM
3. **资源嵌入** (`html.rs:788+`) - 下载并嵌入外部资源
4. **文档序列化** (`core.rs:248`) - 将 DOM 转换为最终 HTML

## 翻译组件最佳集成位置

### 位置 1: DOM 遍历后，序列化前 (推荐)
**文件**: `src/core.rs`  
**行号**: 203 行之后，248 行之前

```rust
// 在这个位置添加翻译处理
// walk(&mut session, &base_url, &dom.document);

// === 翻译组件集成点 ===
if session.options.enable_translation {
    dom = translate_dom_content(&mut session, dom)?;
}

// 继续原有流程
if let Some(new_base_url) = session.options.base_url.clone() {
    dom = set_base_url(&dom.document, new_base_url);
}
```

**优势**:
- 所有资源已经嵌入，DOM 结构完整
- 不影响资源下载和嵌入逻辑
- 翻译后的内容会被正确序列化

### 位置 2: walk 函数内部文本节点处理
**文件**: `src/html.rs`  
**位置**: `walk()` 函数中处理 `NodeData::Text` 时

**优势**:
- 能够精确控制每个文本节点的翻译
- 可以保留原始 DOM 结构

## 翻译组件设计方案

### 1. 在 MonolithOptions 中添加翻译选项

```rust
// src/core.rs - MonolithOptions 结构体
#[derive(Default)]
pub struct MonolithOptions {
    // ... 现有字段 ...
    pub enable_translation: bool,
    pub target_language: Option<String>,
    pub translation_service: Option<String>,
}
```

### 2. 创建翻译模块

**文件**: `src/translation.rs`

```rust
use markup5ever_rcdom::{Handle, NodeData, RcDom};
use crate::session::Session;

pub fn translate_dom_content(session: &mut Session, dom: RcDom) -> Result<RcDom, crate::core::MonolithError> {
    translate_node(session, &dom.document)?;
    Ok(dom)
}

fn translate_node(session: &mut Session, node: &Handle) -> Result<(), crate::core::MonolithError> {
    match node.data {
        NodeData::Text { ref contents } => {
            let text = contents.borrow().to_string();
            if should_translate(&text) {
                let translated = translate_text(session, &text)?;
                contents.borrow_mut().clear();
                contents.borrow_mut().push_slice(&translated);
            }
        }
        NodeData::Element { ref name, .. } => {
            // 处理需要翻译的属性（如 title, alt 等）
            translate_element_attributes(session, node)?;
            
            // 递归处理子节点
            for child in node.children.borrow().iter() {
                translate_node(session, child)?;
            }
        }
        _ => {
            // 递归处理其他类型节点的子节点
            for child in node.children.borrow().iter() {
                translate_node(session, child)?;
            }
        }
    }
    Ok(())
}

fn should_translate(text: &str) -> bool {
    // 判断文本是否需要翻译
    // 排除纯空白、数字、特殊字符等
    let trimmed = text.trim();
    !trimmed.is_empty() && 
    trimmed.len() > 1 && 
    trimmed.chars().any(|c| c.is_alphabetic())
}

fn translate_text(session: &Session, text: &str) -> Result<String, crate::core::MonolithError> {
    // 实现具体的翻译逻辑
    // 可以调用翻译 API 或本地翻译库
    Ok(format!("[翻译]{}", text)) // 占位符实现
}

fn translate_element_attributes(session: &mut Session, node: &Handle) -> Result<(), crate::core::MonolithError> {
    // 翻译元素属性中的文本（如 title, alt, placeholder 等）
    Ok(())
}
```

### 3. CSS 内容翻译处理

在 `src/css.rs` 的 `embed_css` 函数中添加翻译逻辑：

```rust
pub fn embed_css(session: &mut Session, document_url: &Url, css: &str) -> String {
    let mut input = ParserInput::new(css);
    let mut parser = Parser::new(&mut input);
    
    let processed = process_css(session, document_url, &mut parser, "", "", "").unwrap();
    
    // 如果启用翻译，处理 CSS 中的文本内容
    if session.options.enable_translation {
        translate_css_content(session, &processed)
    } else {
        processed
    }
}

fn translate_css_content(session: &Session, css: &str) -> String {
    // 处理 CSS 中的 content 属性、@media 查询等包含的文本
    // 使用正则表达式或 CSS 解析器识别需要翻译的文本
    css.to_string() // 占位符实现
}
```

### 4. 命令行参数集成

在 `src/main.rs` 中添加翻译相关的 CLI 参数：

```rust
#[derive(Parser)]
struct Cli {
    // ... 现有字段 ...
    
    /// Enable translation of page content
    #[arg(short = 'T', long)]
    translate: bool,
    
    /// Target language for translation (e.g., zh-CN, es, fr)
    #[arg(long, value_name = "zh-CN")]
    target_lang: Option<String>,
    
    /// Translation service to use
    #[arg(long, value_name = "google")]
    translation_service: Option<String>,
}

// 在 main 函数中设置选项
options.enable_translation = cli.translate;
options.target_language = cli.target_lang;
options.translation_service = cli.translation_service;
```

## 实现步骤

### 第一阶段：基础框架
1. 在 `MonolithOptions` 中添加翻译选项
2. 创建 `src/translation.rs` 模块
3. 在 `src/lib.rs` 中导出翻译模块
4. 添加命令行参数支持

### 第二阶段：文本提取和处理
1. 实现 DOM 文本节点遍历和翻译
2. 实现元素属性翻译（title, alt 等）
3. 添加文本过滤逻辑（排除不需要翻译的内容）

### 第三阶段：CSS 文本处理
1. 解析 CSS 中的 `content` 属性
2. 处理其他包含文本的 CSS 规则
3. 保持 CSS 语法正确性

### 第四阶段：翻译服务集成
1. 集成具体的翻译 API（Google Translate, DeepL 等）
2. 添加错误处理和重试机制
3. 实现缓存机制避免重复翻译

## 注意事项

### 性能考虑
- 使用批量翻译 API 减少网络请求
- 实现翻译缓存避免重复翻译
- 异步处理大量文本内容

### 兼容性
- 保持现有功能不受影响
- 翻译功能作为可选特性
- 处理各种字符编码

### 错误处理
- 翻译服务不可用时的降级处理
- 网络错误的重试机制
- 不完整翻译的处理

## 使用示例

```bash
# 基本翻译功能
monolith https://example.com --translate --target-lang zh-CN -o translated.html

# 指定翻译服务
monolith https://example.com -T --target-lang zh-CN --translation-service google -o translated.html

# 结合其他选项
monolith https://example.com -T --target-lang zh-CN -I -j -o translated-isolated.html
```

## 测试策略

1. **单元测试**: 测试翻译函数的正确性
2. **集成测试**: 测试整个翻译流程
3. **性能测试**: 测试大文档的翻译性能
4. **兼容性测试**: 确保不影响现有功能